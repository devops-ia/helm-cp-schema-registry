# Default values for helm-cp-schema-registry
# This is a YAML-formatted file
# Declare variables to be passed into your templates

# -- Number of replicas
# Specifies the number of replicas for the service
replicaCount: 1

# -- Image registry
# The image configuration for the base service
image:
  # The repository of the image
  repository: ghcr.io/devops-ia/cp-schema-registry
  # The pull policy for the image
  pullPolicy: IfNotPresent
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

# -- String to partially override cp-schema-registry.fullname template (will maintain the release name)
nameOverride: ""

# -- String to fully override cp-schema-registry.fullname template
fullnameOverride: ""

# -- Docker registry secret names as an array
imagePullSecrets: []
# - name: my-secret-name

# -- Configure strategy for the deployment
strategy: {}
# type: RollingUpdate
# rollingUpdate:
#   maxUnavailable: 1

# -- Enable creation of ServiceAccount
# </br> Ref: https://kubernetes.io/docs/concepts/security/service-accounts/
serviceAccount:
  # Specifies whether a service account should be created
  create: true
  # Automatically mount a ServiceAccount's API credentials?
  automount: true
  # Annotations to add to the service account
  annotations: {}
  # The name of the service account to use
  # If not set and create is true, a name is generated using the fullname template
  name: ""

# -- Enable or disable test connection
testConnection:
  # Specifies whether a test connection should be created
  enabled: false
  # The repository of the image
  repository: busybox
  # Overrides the image tag whose default is the chart appVersion
  tag: ""

# -- Environment variables to configure application
# </br> Ref: https://docs.confluent.io/platform/current/schema-registry/installation/config.html#schemaregistry-config
env:
  SCHEMA_REGISTRY_MASTER_ELIGIBILITY: "true"
  SCHEMA_REGISTRY_HEAP_OPTS: "-Xms512M -Xmx512M"
  #SCHEMA_REGISTRY_SCHEMA_COMPATIBILITY_LEVEL: "full_transitive"
  #SCHEMA_REGISTRY_KAFKASTORE_SECURITY_PROTOCOL: "SSL"
  #SCHEMA_REGISTRY_MASTER_ELIGIBILITY: "true"
  #SCHEMA_REGISTRY_KAFKASTORE_TIMEOUT_MS: 1000
  #SCHEMA_REGISTRY_KAFKASTORE_BOOTSTRAP_SERVERS: ref+tfstates3://{{ .Values.aws.tfstateBucket }}/{{ .Environment.Name }}/msk/terraform.tfstate/output.bootstrap_brokers_sasl_iam
  #SCHEMA_REGISTRY_LOG4J_LOGGERS: "org.apache.kafka=ERROR,io.confluent.rest.exceptions=FATAL,io.confluent.admin.utils.ClusterStatus=ERROR"
  ## IAM
  #SCHEMA_REGISTRY_KAFKASTORE_SECURITY_PROTOCOL: "SASL_SSL"
  #SCHEMA_REGISTRY_KAFKASTORE_SASL_CLIENT_CALLBACK_HANDLER_CLASS: "software.amazon.msk.auth.iam.IAMClientCallbackHandler"
  #SCHEMA_REGISTRY_KAFKASTORE_SASL_JAAS_CONFIG: "software.amazon.msk.auth.iam.IAMLoginModule required;"
  #SCHEMA_REGISTRY_KAFKASTORE_SASL_MECHANISM: "AWS_MSK_IAM"

# -- Variables from configMap
envFromConfigMap: {}
# MY_VARIABLE:
#  name: <name-configmap>
#  key: key

# -- Variables from secrets
envFromSecrets: {}
# MY_VARIABLE:
#  name: <name-secret>
#  key: secret_key

# -- Variables from files managed by you
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/#configure-all-key-value-pairs-in-a-configmap-as-container-environment-variables
envFromFiles: []
# - secretRef:
#     name: <name-secret>
# - configMapRef:
#     name: <name-configmap>

# -- Secrets values to create credentials and reference by envFromSecrets
# Generate Secret with following name: <release-name>-<name>
# </br> Ref: https://kubernetes.io/docs/concepts/configuration/secret/
secrets: []
# - name: secret-name
#   data:
#     my.key: |-
#       my-content
#     my_var: my-value

# -- ConfigMap values to create configuration files
# Generate ConfigMap with following name: <release-name>-<name>
# </br> Ref: https://kubernetes.io/docs/concepts/configuration/configmap/
configMaps: {}
# - name: configmap-name
#   data:
#     my.key: |-
#       my-content
#     my_var: my-value

# -- Configure additional containers
# </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
initContainers: []
# - name: my-container
#   image: busybox
#   command: ['sh', '-c', 'echo "Hello, World!"']

# -- Configure hostAliases
# </br> Ref: https://kubernetes.io/docs/tasks/network/customize-hosts-file-for-pods/
hostAliases: []

# -- Configure args
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
args: []
# - -c
# - echo "Hello, World!"

# -- Configure command
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/define-command-argument-container/
command: []
# - echo
# - "Hello, World!"

# -- Kubernetes service to expose Pod
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/service/
service:
  # -- Kubernetes Service type. Allowed values: NodePort, LoadBalancer, ClusterIP, ExternalName
  type: ClusterIP
  # -- Kubernetes Service port
  port: 80
  # -- Pod expose port
  targetPort: 8080
  # -- Protocol for the service port
  protocol: TCP
  # -- Name for the service port
  portName: http
  # -- Application protocol (HTTP, HTTPS, etc.)
  appProtocol: HTTP
  # -- NodePort port (only when type is NodePort or LoadBalancer)
  # nodePort: 32000
  # -- Specific cluster IP (use "None" for headless service)
  # clusterIP: "10.96.0.1"
  # -- List of cluster IPs for dual-stack
  # clusterIPs:
  #   - "10.96.0.1"
  #   - "fd00::1"
  # -- External IPs for the service
  # externalIPs:
  #   - "192.168.1.100"
  # -- LoadBalancer specific configuration
  loadBalancer: {}
  # -- LoadBalancer IP (only for LoadBalancer type)
  # ip: "192.168.1.100"
  # -- LoadBalancer source ranges (CIDR blocks)
  # sourceRanges:
  #   - "10.0.0.0/8"
  #   - "172.16.0.0/12"
  # -- LoadBalancer class
  # class: "nginx"
  # -- Allocate NodePorts for LoadBalancer service
  # allocateNodePorts: true
  # -- External name for ExternalName type service
  # externalName: "example.com"
  # -- External traffic policy (Local or Cluster)
  # externalTrafficPolicy: Local
  # -- Internal traffic policy (Local or Cluster)
  # internalTrafficPolicy: Local
  # -- Health check node port (for LoadBalancer with externalTrafficPolicy: Local)
  # healthCheckNodePort: 30000
  # -- Publish not ready addresses
  # publishNotReadyAddresses: false
  # -- Session affinity (None or ClientIP)
  # sessionAffinity: ClientIP
  # -- Session affinity configuration
  # sessionAffinityConfig:
  #   clientIP:
  #     timeoutSeconds: 10800
  # -- IP families (IPv4, IPv6)
  # ipFamilies:
  #   - IPv4
  #   - IPv6
  # -- IP family policy (SingleStack, PreferDualStack, RequireDualStack)
  # ipFamilyPolicy: SingleStack
  # -- Traffic distribution (PreferClose)
  # trafficDistribution: PreferClose
  # -- Additional labels for the service
  labels: {}
  #  environment: production
  #  team: platform
  # -- Annotations for the service
  annotations: {}
  #   service.beta.kubernetes.io/aws-load-balancer-type: "nlb"
  #   service.beta.kubernetes.io/aws-load-balancer-backend-protocol: "tcp"
  #   nginx.ingress.kubernetes.io/service-upstream: "true"
  # -- Pod extra ports
  extraPorts: []
  #  - name: admin
  #    port: 9090
  #    targetPort: 9090
  #    protocol: TCP
  #    appProtocol: HTTP
  #    nodePort: 32001  # Only for NodePort/LoadBalancer
  #  - name: grpc
  #    port: 9000
  #    targetPort: 9000
  #    protocol: TCP
  #    appProtocol: GRPC

# -- NetworkPolicy configuration
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/network-policies/
networkPolicy:
  # -- Enable or disable NetworkPolicy
  enabled: false
  # -- Policy types
  policyTypes: []
  # - Ingress
  # - Egress
  ingress: []
  # - from:
  #   - ipBlock:
  #       cidr: 172.17.0.0/16
  #       except:
  #       - 172.17.1.0/24
  #   - namespaceSelector:
  #       matchLabels:
  #         project: myproject
  #   - podSelector:
  #       matchLabels:
  #         role: frontend
  #   ports:
  #   - protocol: TCP
  #     port: 6379
  egress: []
  # - to:
  #   - ipBlock:
  #       cidr: 10.0.0.0/24
  #   ports:
  #   - protocol: TCP
  #     port: 5978

# -- Configure lifecycle hooks
# </br> Ref: https://kubernetes.io/docs/concepts/containers/container-lifecycle-hooks/
# </br> Ref: https://learnk8s.io/graceful-shutdown
lifecycle: {}
# preStop:
#   exec:
#     command: ["sh", "-c", "sleep 10"]

# -- Configure Pod termination grace period
# </br> Ref: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#pod-termination
terminationGracePeriodSeconds: 30

# -- Configure liveness checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
livenessProbe:
  enabled: false
  failureThreshold: 3
  initialDelaySeconds: 180
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

# -- Custom livenessProbe
livenessProbeCustom: {}
# httpGet:
#   path: /dashboard
#   port: 4000
# failureThreshold: 3
# initialDelaySeconds: 200
# periodSeconds: 30
# successThreshold: 1
# timeoutSeconds: 5

# -- Configure readinessProbe checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
readinessProbe:
  enabled: false
  failureThreshold: 3
  initialDelaySeconds: 10
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 1

# -- Custom readinessProbe
readinessProbeCustom: {}
# httpGet:
#   path: /dashboard
#   port: 4000
# failureThreshold: 3
# initialDelaySeconds: 200
# periodSeconds: 30
# successThreshold: 1
# timeoutSeconds: 5

# -- Configure startupProbe checker
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-liveness-readiness-startup-probes/#define-startup-probes
startupProbe:
  enabled: false
  failureThreshold: 30
  initialDelaySeconds: 180
  periodSeconds: 10
  successThreshold: 1
  timeoutSeconds: 5

# -- Custom startupProbe
startupProbeCustom: {}
# httpGet:
#   path: /dashboard
#   port: 4000
# failureThreshold: 3
# initialDelaySeconds: 200
# periodSeconds: 30
# successThreshold: 1
# timeoutSeconds: 5

# -- Configure annotations on Deployment
annotations: {}

# -- Configure labels on Deployment
labels: {}

# -- Configure annotations on Pods
podAnnotations: {}

# -- Configure labels on Pods
podLabels: {}

# -- Defines privilege and access control settings for a Pod
# </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
podSecurityContext: {}
# fsGroup: 2000

# -- Defines privilege and access control settings for a Container
# </br> Ref: https://kubernetes.io/docs/concepts/security/pod-security-standards/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/security-context/
securityContext: {}
# capabilities:
#   drop:
#   - ALL
# readOnlyRootFilesystem: true
# runAsNonRoot: true
# runAsUser: 1000

# -- Ingress configuration to expose app
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/ingress/
ingress:
  enabled: false
  className: ""
  annotations: {}
  # kubernetes.io/ingress.class: nginx
  # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

# -- Resources limits and requested
# </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
resources: {}
# limits:
#   cpu: "1500m"
#   memory: 2048Mi
# requests:
#   cpu: 1
#   memory: 256Mi

# -- Pod Disruption Budget
# </br> Ref: https://kubernetes.io/docs/reference/kubernetes-api/policy-resources/pod-disruption-budget-v1/
podDisruptionBudget:
  enabled: false
  maxUnavailable: 1
  minAvailable:
# -- Autoscaling with CPU or memory utilization percentage
# </br> Ref: https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/
autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

# -- Additional volumes on the output Deployment definition
# </br> Ref: https://kubernetes.io/docs/concepts/storage/volumes/
# </br> Ref: https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/
# </br> Ref: https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/#create-a-pod-that-has-access-to-the-secret-data-through-a-volume
volumes: []
# - name: foo
#   secret:
#     secretName: mysecret
#     optional: false

# -- Additional volumeMounts on the output Deployment definition
volumeMounts: []
# - name: foo
#   mountPath: "/etc/foo"
#   readOnly: true

# -- Node labels for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#nodeselector
nodeSelector: {}

# -- Tolerations for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/taint-and-toleration/
tolerations: []

# -- Affinity for pod assignment
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/assign-pod-node/#affinity-and-anti-affinity
affinity: {}

# -- Control how Pods are spread across your cluster
# </br> Ref: https://kubernetes.io/docs/concepts/scheduling-eviction/topology-spread-constraints/#example-multiple-topologyspreadconstraints
topologySpreadConstraints: []
# - maxSkew: 1
#   topologyKey: zone
#   whenUnsatisfied: DoNotSchedule

# -- Configure DNS
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
dnsConfig: {}
# nameservers:
#   - 1.2.3.4
#   - 5.6.7.8
# searches:
#   - ns1.svc.cluster.local
#   - my.dns.search.suffix
# option:
#   - name: ndots
#     value: "2"
#   - name: edns0
#   - name: timeout
#     value: "3"

# -- Configure DNS policy
# Options: ClusterFirst, Default, ClusterFirstWithHostNet, None
# </br> Ref: https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/
dnsPolicy: ClusterFirst

# -- Enable metrics
metrics:
  # -- Enable or disable
  enabled: false

  # -- Expose metrics port
  port: 5555

  # -- prometheus-jmx-exporter configuration
  exporter:
    # -- Enable or disable
    enabled: false

    # -- Expose exporter port
    port: 5556

    # -- Image registry
    # The image configuration for the base service
    image:
      # The repository of the image
      repository: solsson/kafka-prometheus-jmx-exporter@sha256
      # The pull policy for the image
      pullPolicy: IfNotPresent
      # Overrides the image tag whose default is the chart appVersion
      tag: "6f82e2b0464f50da8104acd7363fb9b995001ddff77d248379f8788e78946143"

    # -- Resources limits and requested
    # </br> Ref: https://kubernetes.io/docs/concepts/configuration/manage-resources-containers/
    resources: {}
      # We usually recommend not to specify default resources and to leave this as a conscious
      # choice for the user. This also increases chances charts run on environments with little
      # resources, such as Minikube. If you do want to specify resources, uncomment the following
      # lines, adjust them as necessary, and remove the curly braces after 'resources:'
      # limits:
      #   cpu: 100m
      #   memory: 128Mi
      # requests:
      #   cpu: 100m
      #   memory: 128Mi

# -- Enable ServiceMonitor to get metrics
# </br> Ref: https://github.com/prometheus-operator/prometheus-operator/blob/main/Documentation/api.md#servicemonitor
serviceMonitor:
  # -- Enable or disable
  enabled: false
  interval: 30s
  scrapeTimeout: 10s
  metricRelabelings: []
  relabelings: []

# -- Extra Kubernetes manifests to deploy
extraObjects: []
# - apiVersion: batch/v1
#   kind: CronJob
#   metadata:
#     name: hello
#   spec:
#     schedule: "* * * * *"
#     jobTemplate:
#       spec:
#         template:
#           spec:
#             containers:
#             - name: hello
#               image: busybox:1.28
#               imagePullPolicy: IfNotPresent
#               command:
#               - /bin/sh
#               - -c
#               - date; echo Hello from the Kubernetes cluster
#             restartPolicy: OnFailure
